/*
 * @author whimsycwd
 * @date   2014.10.4
 * 
 * Binary Search Trees
 * key is a integer
 *
*/

#include<iostream>
#include<memory>
#include<vector>

#include "Node.h"

using namespace std;

const static int NIL_CONST = -1;
const static shared_ptr<Node> Nil = shared_ptr<Node>(new Node(NIL_CONST));   // sentinel

class BST {
    private :
        shared_ptr<Node> root;
    


        shared_ptr<Node> makeNode(int key) {
            shared_ptr<Node> retValue = shared_ptr<Node>(new Node(key));
            retValue->lc = Nil;
            retValue->rc = Nil;
            retValue->p = Nil;
            retValue->size = 1;
            return retValue;
        }

        void fix_size(shared_ptr<Node> x) {
            while (x != Nil) {
                x->size = x->lc->size + x->rc->size;
                x = x->p;
            }
        }

        // because we need to maintain parent pointer, so it's unconvience to write in recursive way.
        void add(shared_ptr<Node> z) {
            auto y = Nil;
            auto x = root;
            
            while (x != Nil) {
                y = x;
                if      (z->key < x->key) x = x->lc;
                else if (z->key > x->key) x = x->rc;
                else return;                   // ignore duplicate key
            }

            z->p = y;

            if      (y == Nil)          root = z;
            else if (z->key < y->key)   y->lc = z;
            else                        y->rc = z;


            fix_size(z);
            
        }

        //  Note that TRANSPLANT does not attemp to update v.left 
        //  and v.right; doing so, or not doing so, is the responsibility
        //  of TRANSPLANT's caller
        void transplant(shared_ptr<Node> u, shared_ptr<Node> v) {
            if (u->p == Nil) root = v; 
            else if (u == u->p->lc) u->p->lc = v;
            else u->p->rc = v;

            v->p = u->p;
            
            // TODO: necessary?
            fix_size(v);
        }

        void del(shared_ptr<Node> z) {
            if      (z->lc == Nil) transplant(z, z->rc);
            else if (z->rc == Nil) transplant(z, z->lc);
            else {
                auto y = min(z->rc);
                if (y->p != z) {
                    transplant(y, y->rc);
                    y->rc = z->rc;
                    y->rc->p = y;
                }
                transplant(z, y);
                y->lc = z->lc;
                y->lc->p = y;
                fix_size(y);
            }

        }

        shared_ptr<Node> min(shared_ptr<Node> x) {
            if (x == Nil) return Nil;
            while (x->lc != Nil) {
                x = x->lc;
            }
            return x;
        }
        shared_ptr<Node> max(shared_ptr<Node> x) {
            if (x == Nil) return Nil;
            while (x->rc != Nil) {
                x = x->rc;
            }
            return x;
        }

        shared_ptr<Node> prev(shared_ptr<Node> x) {
            if (x->lc != Nil) {
                return max(x->lc);
            }
            
            auto y = x->p;
            while (y != Nil && x == y->lc) {
                x = y;
                y = y->p;
            }
            return x;

        }

        shared_ptr<Node> succ(shared_ptr<Node> x) {
            if (x->rc != Nil) {
                return min(x->rc);
            }
            auto y = x->p;

            while (y != Nil && x == y->rc) {
                x = y;
                y = y->p;
            }
            return x; 
        }

        shared_ptr<Node> find(int key) {
            auto x = root;
            while (x != Nil) {
                if      (x->key == key) return x;
                else if (key < x->key)  x = x->lc;
                else                    x = x->rc; 
            }
            return x;
        }
        void walk(vector<int> &vec, shared_ptr<Node> root) const{
            if (root == Nil) return;
            
            walk(vec, root->lc);
            vec.push_back(root->key);
            walk(vec, root->rc);
        }
        void walk(vector<int> &vec) const {
            walk(vec, root);
        }
        
        int size(shared_ptr<Node> x) {
            return x->size;
        }
        shared_ptr<Node> select (shared_ptr<Node> x, int k) {
            int t = size(x->lc);
            if      (k < t) return select(x->lc, k);
            else if (k > t) return select(x->rc, k - t - 1);
            else            return x; 

        }

        int rank(shared_ptr<Node> x, int key) {
            if (x == Nil) return 0;
            if      (key < x->key)  return rank(x->lc, key);
            else if (key > x->key)  return 1 + size(x->lc) + rank(x->rc, key);
            else                    return size(x->lc);
        }



    public : 
        BST() {
            root = Nil;
        }

        // add new elements
        void add(int key) {
            add(shared_ptr<Node>(makeNode(key)));
        }

        void del(int key) {
            shared_ptr<Node> x = find(key);
            if (x != Nil) del(x);
        }

        int min() {
            return min(root)->key;
        }

        int max() {
            return max(root)->key;
        }
        int size() {
            return size(root);
        }


        /******************************
         *  Rank and selection
         *****************************/

        int select(int k) {
            if (k < 0 || k >= size()) return NIL_CONST;
            shared_ptr<Node> x = select(root, k);
            return x->key;
        }

        int rank(int key) {
            return rank(root, key);
        }

        friend ostream & operator<<(ostream &os, const BST &tree);
};

ostream  &operator<<(ostream& os, const BST& tree) {
    vector<int> vec;    
    tree.walk(vec);    
    
    os << "[";    
    for (auto iter = vec.begin(); iter != vec.end(); ++iter) {
        if (iter == vec.begin()) os << *iter;
        else os << " " << *iter;
    }
    os << "]";
    return os;
}

